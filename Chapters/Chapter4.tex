% Chapter 4
%----------------------------------------------------------------------------------------
\section{A WSN with Waspmotes: Implementation aspects}
\subsection{Introduction}
In this section the program running on the WSN nodes will be discussed. To start programming, Libelium offers its customers a customized IDE and a fairly extensive API. The IDE uses the same compiler (AVR) and core libraries as the Arduino IDE. The IDE is ideal to upload small examples and test programs. However, to facilitate programming and to obtain more C/C++ support, expanding the API is a better approach. This will be discussed more in section \ref{LibAPI}.\\
After experimenting with the ZigBee sleep modes it became clear that some unstable results caused by delayed pending messages for end devices could not be avoided. The program does support XBee sleep modes but this section will only discuss stable operation modes. From now on, we will no longer differentiate between ZigBee routers and ZigBee end devices, but the sleep options will be controlled via Waspmote sleep modes, as recommended by Libelium \defcitealias{LIB_SLEEP}{Libelium-dev, 2013}\citepalias{LIB_SLEEP}. So a ZigBee router forced to sleep as well as a ZigBee end device will be considered as an 'End Device'. 

%---------------------------------------------------

\subsection{Program Structure}
When ZigBee sleep modes are ignored, basically three different programs suffice to program the entire network. There is one program to support the gateway (which is also the ZigBee coordinator) to analyse the data received from the other nodes, which will be discussed in section \ref{extracting}. All the other nodes run either a 'Router' program or an 'End Device' program and are designed to collect and send data to the gateway. The only difference between these last programs is that a 'Router' program does not implement the sleep modes. Before continuing to the next sections, please have a look at the full 'End Device' program flowchart shown in figure \ref{fig:flow}.

\subsubsection{Initialization}
Figure \ref{fig:fsm} shows the simplified underlying logic of a dynamic C implementation of ZigBee at the application level. In one cycle each node has to associate with the network, measure some sensors, send the measured samples and possibly enter a sleep mode before repeating this cycle, depending on whether it has a 'Router' program or 'End Device' program running.\\ 
\begin{figure}[ht]
\centering
\includegraphics[width=0.35\textwidth]{fsm}
\caption{ZigBee Application State Machine}
\label{fig:fsm}
\end{figure}
\paragraph{Device start-up: Full initialization}
When the program is executed for the first time, a full XBee setup will be executed with the parameters entered via the Libelium IDE. To ensure stability it takes about 8 seconds to write the settings to the XBee, to reset it afterwards (turn the power off and back on) and finally to perform the joining process. From this moment on the node will send its battery level to the coordinator and wait to receive its physical sensor layout settings. Until such an 'ADD\_NODE\_REQUEST' packet is received the sleeping time will gradually be increased in order to save battery power.
\paragraph{Next cycles: Reduced initialization}
By not resetting the PAN ID but by fetching it from the XBee's memory, the joining process only takes about two seconds\footnote{By enabling ZigBee sleep the node does not lose the association with its parent and the re-joining process only takes about 10ms. However, the time needed to receive messages pending in router devices varies between 5 and 15 seconds and is never compensated by the faster joining process. There is also no guarantee that pending messages will be received or in which order they will be received, so network stability can no longer be guaranteed.} (Please see appendix \ref{fig:envA} for more measurement results). Unfortunately a disadvantage of this shortened setup is that the XBee is no longer able to detect if the coordinator or his parent is actually available. The result of the association check is not always correct and the program will only notice this for the first time when it is trying to send a message. If this function results in a send error the program will do a full setup routine and resend the message. If the node then fails again to send the message we can conclude that the coordinator is really off-line or that there are no joinable nodes within range. In that case the measured sensors will be saved and tried to send during the next cycles. In order not to lose results, a system administrator will be notified if a node fails to report for several consecutive cycles.

\subsubsection{Measuring sensors}
sensor float to bytes conversion... ...
\paragraph{Sending samples}
escaping zeros... ...
app ID = 10: 'IO\_DATA'... ...
see appendix ?? for all our packets... ...
\paragraph{Wait for received messages}
Since this mode does not use ZigBee sleep, end devices can only receive messages when the are turned on. To coordinate this, end devices will check messages for a fixed amount of time just after sensor data has been sent.\\
This means the Waspmote will only wake up when sensors have to be measured. Whereas in the next section ZigBee sleep is enabled and the Waspmote may also wake for polling, in order to avoid that messages buffered in routers get lost (since Waspmote v1.1 cannot be interrupted by available XBee RF Data). 


\subsubsection{Sending and Receiving}
\label{frames1}
In the API of Waspmote v1.1 Libelium uses an 'Application Header' which is shown in figure \ref{fig:appH} to send and receive data. This header takes care of packet fragmentation if packets exceed the maximum payload limit and can also be used by the receiver to treat the packet or fragment. The header itself is sent inside the RF Data field of the API Frame Structure (see figure \ref{fig:frames}).\\
\begin{figure}[ht]
\centering
\includegraphics[width=0.48\textwidth]{appHeader}
\caption{Application Header}
\label{fig:appH}
\end{figure}
The Waspmote and gateway programs use the 'Application ID' field in this header to distinguish different data in sent packets. In a first approach this extra layer we developed also serves as acknowledgement in the communication protocol. Depending on the 'Application ID' the layer contains a sensor mask is (a 16 bit-flag) and data. Examples are 'ADD\_NODE\_REQ' and 'CH\_SENS\_FREQ\_REQ'. Appendix \ref{OwnProtocolLabel} shows a complete overview off all options.\\
To easily switch between the different requests and select the sensors contained in the received mask the program uses static function pointers. An example is given below:
\usestyle{vs} %other useful styles are, bw,  borland, vs
% Include the source code 
\includecode{fp.cpp}

\subsubsection{Without ZigBee sleep mode}
%In this mode there is no difference between routers and end devices on XBee level. The only difference in program execution is that the sleeping period is skipped for routers.
The user can set the device role during setup or even later on by sending a command to the Waspmote, which makes it easy to change a mote's device role. The device role is stored in the xbeeZB device type identifier (see \defcitealias{ZBGUIDE}{Waspmote ZigBee Networking Guide, 2012}\citepalias{ZBGUIDE} and '\textbf{WaspXBeeZBNode.h}').
To better understand the next sections please have a quick look at the program flow chart in figure \ref{fig:flow}.





%According to Libelium their IDE has been properly tested and proven to assure optimum operation. Unfortunately we cannot agree with this. 
%Libelium also offers a lot of program examples on their website. Sadly most of them don't work like Libelium claims they do.
\subsection{AVR compiler}
\subsubsection{Toolchain Overview}
To develop software for an AVR microcontroller several tools are working together. This group of tools produces the final executable and is commonly called a toolchain and is shown in figure \ref{fig:tool}. 
\begin{figure}[ht]
\centering
\includegraphics[width=0.26\textwidth]{avr}
\caption{Overview of the AVR toolchain}
\label{fig:tool}
\end{figure}
\paragraph{GCC:} AVR uses the open source GNU Compiler Collection (GCC) with AVR microcontroller as target system. This version of GCC is known as 'AVR GCC' \defcitealias{AVR}{AVR-Libc User Manual, 2008}\citepalias{AVR}. GCC differs from other compilers, it only focuses on translating high level language to target assembly. For AVR GCC there are 3 language options: C, C++ and Ada. 
\paragraph{GNU Binutils: }The next step is done by another open source project called GNU Binutils. This contains the GNU assembler and GNU linker.
\paragraph{AVR-libc:} GCC and Binutils provide the tools to make the machine code but one critical component they do not provide is the Standard C Library. The open source AVR toolchain therefore comes with its own open source C Library project which contains many of the same functions found in the regular Standard C Library. It also adds many additional library functions that are specific to  AVR microcontrollers.
\paragraph{GNU Make:} Finally all pieces must be tied together. This is done by Make, which interprets and executes the Makefile of the project.
%------------------------------
\subsubsection{Memory Sections}
\label{memory}
The available non-volatile memory sections are the \textbf{.text} section (FLASH), which contains the actual machine instructions and the \textbf{.eeprom} section. Many AVR devices have a minimal amount of RAM. This limited amount of runtime memory needs to be shared between the following memory sections:
\begin{enumerate}
\item Initialized variables and static data such as\\ \verb+char message[] = "An error message"+ are stored in \textbf{.data variables}
\item Uninitialized global or static variables: \textbf{.bss variables}
\item Dynamic memory: \textbf{heap}
\item Area used for calling subroutines and storing local variables: \textbf{stack}
\end{enumerate}
The standard RAM layout is shown in figure \ref{fig:RAM}. Since there is no hardware supported memory management, separate regians can overwrite each ohter. Heap and stack can collide if either of them require large memory space or even when the allocations aren't high at all but because heap allocations get fragmented over time and new request don't fit in freed areas.
\begin{figure}[ht]
\centering
\includegraphics[width=0.48\textwidth]{ram}
\caption{AVR / ATmega1281 standard RAM layout}
\label{fig:RAM}
\end{figure}\\
As discussed in section \ref{memory} the ATmega1281 is uses a modified Harvard architecture, meaning that data can also be stored in program memory space. This is useful when you have constant data and you're running out of room to store it. Remember that many AVRs have limit amount of RAM to store data, but may have available FLASH space left. For the compiler this is however a challenge, which is exacerbated by the fact that the C Language was designed for Von Neumann architectures. So the AVR compiler has to use other means to operate with these separate address spaces (cf. pointer usage). The AVR toolset used the GCC \verb+__attribute__+ keyword, which is used to attach different attributes to function declarations and variables. AVR GCC provides a special attribute called \verb+progmem+ for data declarations and tells the compiler to store the data in Program Memory. To increase the convenience to the end user AVR-libc provides a simple macro \verb+PROGMEM+ which can be found in 'avr/pgmspace.h'. To read the data another macro is provided, which generates the correct address to retrieve the data from Program Memory. Storing data in Program Space incurs extra overhead in terms of instructions and execution time, but usually this is minimal compared to the space savings.\\
\subsubsection{Memory problems}
Libelium's Programming Style Guide warns its users about the amount of memory \verb+USB.print("Test message!")+ requires. The program memory increases due to the instructions and arguments (the chars) needed to print the string, since the message needs to be put in RAM memory first also there precious memory is lost (see the assembly extract in appendix ??).\\
Libelium recommends to do the following:
\usestyle{vs} %other useful styles are, bw,  borland, vs
% Include the source code 
\includecode{mem1.cpp}
This however still uses both program and data memory and is only useful if one wants to print the same message in different parts of the program, so this is not really a solution. The only way to save RAM memory while printing messages is to hard code them into the heap by doing the following:
\usestyle{vs} %other useful styles are, bw,  borland, vs
% Include the source code 
\includecode{mem2.cpp}
A less cumbersome way would be to give the message and an address where to store the message as argument of a recursive matrix which does this operation for us. However, standard C Language macro's cannot simply split a string into characters. So the only ways to save RAM is to hard code the string as data or to store the string in Program Space and use the \verb+strcpy_P+ to copy the string to stack when it is needed. 
\subsection{Libelium IDE and API}
\subsubsection{Waspmote-IDE}
The Libelium IDE offers some advantages compared to using other IDE's. For example by using Eclipse it is possible to update programs that are to big ( > 120KB ), over-writing the bootloader. Then they must be sent back to Libelium to restore them. The Waspmote IDE does not allow this accident, so Libelium does not support using other IDE's in an official way so that there is no valid warranty if you've erased the bootloader. Their IDE is far from perfect however, some issues we've experienced are:\\
\begin{itemize}
\item Opening a second or more instance of the IDE sometimes re-opens the previously active files, making it confusing to detect which one you were working in so you end up with two unsaved versions of the same code.
\item Once you start compiling (which takes a lot of time) there's no way to stop it, the stop button does not work.
\item Uploading immediately after compiling will first re-compile it anyway.
\item There is no complete C/C++ support. For example using simple enums is not possible. A workaround is to place the code in additional .h or .cpp files.
\item Auto-completion for the Libelium API functionality would be a great addition.
\end{itemize}
\bigskip
Also the Waspmote's (V1.1) hardware slows down the programming process:
\begin{itemize}
\item Uploading the code takes a lot of time: 1.5 - 2 minutes.
\item The uploading process fails if:
\begin{itemize}
\item The XBee is present
\item The hibernate jumper is not present when the mote is in hibernate
\item The little power switch has been turned off
\end{itemize}
\end{itemize}
Often you will want to turn off the power switch temporarily to analyse the content of the serial monitor. Especially in pair programming there is often one requirement you forget and the Waspmote does not check for this on beforehand. It will first compile and do as if it is uploading your code, disappointing you at the end of the process.\\
When debugging bigger program these actions come even more annoying. Suppose you are testing a program which measures sensors, sends the values and hibernates. Then you must:
\begin{enumerate}
\item Remove the sensor board
\item Place the hibernate jumper
\item Remove the XBee
\item Upload
\item Place the XBee
\item Remove the hibernate jumper
\item Re-mount the sensor board
\end{enumerate}
And this is not the end of the list. Removing the hibernate jumper causes the Waspmote to crash one out of two times. Resetting the mote has no effect in this case, just keep inserting and removing the little jumper until it agrees with what you want.
%------------------------------------
\subsubsection{Waspmote-API}
\label{LibAPI}
To facilitate the programming Libelium offers a quite big API and after some exploring you are quickly started with it. The structure of the API is very simple, there is little to no inheritance. In this section, the most important classes are indicated with a red box and are recommended to explore before starting future programming.
\paragraph{Original structure}
Each module or concept has its own class, for example all RTC functions are in 'WaspRTC.h' and 'WaspRTC.cpp'. To be able to use those functions in the IDE an object from the class 'WaspRTC' must be created. This object is created by default by the library and it is public to all libraries. All types to be run on the API can be found in the 'WaspClasses.h' file and each file also includes this file so it is aware of all available types. Please see appendix \ref{appendixC} for a complete overview.\\
For our application WaspXBeeZB is one of the most important classes. It inherits from WaspXBee Core and this way it is also related to the WaspXBee class. Figure \ref{fig:API2} displays the relationship with the AVR-libc libraries and the Waspmote hardware. For example \verb+typedef unsigned char uint8_t+ can be found in 'stdint.h'.\\ 
\begin{figure*}[ht]
\centering
\includegraphics[width=0.98\textwidth]{API2}
\caption{Reduced dependency of Waspmote core libraries}
\label{fig:API2}
\end{figure*}
\noindent During the development of our program the Waspmote showed several strange effects that could only be explained by bad stack management or heap and stack conflicts. Because of this lack of free memory (SRAM, 8KB) we discovered that the V1.1 API wastes a lot of memory by always including all libraries despite not using them. As a fix Libelium recommends to remove all classes you do not use, and there fields that are used in other classes, 'just' going through the compiler errors one by one. After this our program had enough free memory and showed normal behaviour.
%------------------------------------
\paragraph{Added functionality}
To facilitate programming extra functionality has been added to the Libelium API. They are inside files containing the original name with the 'Utils' addition, for example 'WaspRTCUtils.h' and can be found in 'BjornClasses.h'.
%----------------------------------------------------------------  




%----------------------------------------------------------------------------------------
\subsection{Sleep options}
After default configuration the Waspmote will send only its battery level to the default gateway, check for received commands and go into hibernate mode for 1 minute. In a first approach, which focusses on longer battery life, ZigBee sleep options are not taken into account. With ZigBee sleep enabled, routers and coordinators can buffer incoming RF data for their end device children. However, they can only do this up to 30 seconds \defcitealias{XBEE}{XBee/XBee-Pro ZB RF Modules User Manual, 2012}\citepalias{XBEE}. When an end device sleeps longer than 30 seconds, they should send a transmission when they wake to inform other devices that they are awake and can receive data. This is exactly what the first approach does, except it completely disconnects the XBee and sleep intervals are much longer.\\
To make the web service more reactive, this latency has been removed in the second approach. Here XBee sleep is enabled and end devices will respond to commands within 30 seconds.
In a last approach we have a look at how the energy usage of the first approach can be optimized even more.  
\subsubsection{Without ZigBee sleep}
This section discusses algorithms which can be used to measure sensors at variable times. It supposes the Waspmote uses either \textit{Hibernate} or \textit{Sleep} mode, completely disconnecting the XBee. Since it is not possible to combine RTC for both hibernate and sleep mode, a tweak has been implemented to use the Watchdog instead. This way the program can automatically chose which sleep mode to invoke, depending on the next duration to sleep. In hibernation mode the node is completely disconnected from the main battery and the program stops. This makes that all variables lose their values and must be stored in EEPROM memory. Each of the next techniques present with benefits and drawbacks and since we are working with embedded systems with limited possibilities, one should also consider to limit the users options to facilitate the calculations.
\paragraph{Calculate only the next time to sleep}
Each algorithm will have to store the individual sleep times per sensor. To support this algorithm also a copy of the original time will be saved and each time the node wakes up it will look for the smallest next time to sleep. This number will be subtracted from the other sleep times in the array. When a value becomes zero it will be restored with its original value and the cycle continues.  For an example which demonstrates this process please see appendix \ref{AppendixC}.\\
This process is fast and simple. However, the main advantage is that the node has to write to EEPROM each time it wakes up. According to the Atmel datasheet, the EEPROM of the ATmega1281 has an endurance of at least 100,000 write / erase cycles. The following equation indicates the problem for an interval of 10 seconds:
\begin{equation}
\frac{100000 \mathrm{writes} \cdot 10 \mathrm{s}}{60 \mathrm{s} \cdot 60 \mathrm{min} \cdot 24 \mathrm{h}}= 11,57 \: \mathrm{days} 
\label{eq:1}
\end{equation}
But the processors has 4Kbytes EEPROM on board so we don't have to write to the same place every time. Since EEPROM is written on a 'per cell' basis this can extend the lifetime. Our sensor mask can contain up to 16 values of 2 bytes. This leads to the next result:
\begin{equation}
\frac{100000 \mathrm{writes} \cdot 10 \mathrm{s} \cdot 4\mathrm{KB}}{60 \mathrm{s} \cdot 60 \mathrm{min} \cdot 24 \mathrm{h} \cdot 365\mathrm{days} \cdot 32\mathrm{B}} = 3,96\: \mathrm{years}
\end{equation}
We still must store where the data is stored but this won't cause big problems since we only have to rewrite this cell 125 times:
\begin{equation}
\frac{4\mathrm{KB}}{32\mathrm{B}} = 125 \: \mathrm{writes}
\end{equation}
\paragraph{Calculate all next times to sleep}
Another possibility is calculate as much as possible or maybe even all sleep necessary times. This algorithm first calculates the least common divider of the given measuring intervals. Afterwards memory is allocated to store the multiples of the values. When the LCM divided by the smallest measuring interval is smaller than the size of the allocated space, all values can be stored in EEPROM. If this is not the case also the last multiplier of the measuring interval must be stored, so when the last value is reached, the next series can be calculated.\\
Each time the Waspmote wakes up, it will compare its current RTC value with the times stored in EEPROM. The biggest stored time that is an integer multiple of the RTC value is the current position in the array. With this time the sensors to measure and the next time to sleep can be determined.
\paragraph{Limit user control}
Depending on the next time to sleep the program could decide for itself to go into hibernate, deepsleep or sleep with XBee sleep mode. Also, when the program detects inefficient measuring intervals, for example, 1 minute and 2 minutes 10 seconds, this can be notified to the installer or even be refused during setup.
%----------------------------
\subsubsection{With ZigBee sleep}
\paragraph{Managing End Devices}
ZigBee end devices are intended to be battery powered and are capable of sleeping for extended periods of time. Because of this, routers and coordinators use packet buffers and transmission timeouts to ensure reliable data delivery to end devices.\\
When an end device joins the network, a parent-child relationship is formed with a router or the coordinator. From then on, if the end device is awake, it will send poll request messages (by default every 100 ms) to its parent to determine if the parent has any data buffered for it, independent of the sleep mode. Routers buffer this data only up to 28 - 30 seconds, so if we want to ensure reliable communication, this is the maximum sleep time. The child poll timeout can however be set up to a couple of months, so an end device can sleep longer than 30 seconds and still be considered to be in the network. This includes the node is associated within a few milliseconds, compared to the 2.5 seconds mentioned in section \ref{startup}. End devices can choose between two sleep modes, discussed in the next sections. 
\paragraph{Pin sleep}
In this mode an external microcontroller controls when the XBee should sleep and when it should wake by controlling pin 13. The module will not respond to serial or RF data when it is sleeping.\\\\
\textbf{+} lowest power consumption\\
\textbf{+} external controller can take samples without powering up the radio\\
\textbf{-} ZigBee protocol has less control\\
\textbf{-} external controller's timer is not accurate enough to synchronize the network\\
\textbf{-} Need fully awake parent\\
\paragraph{Cycle sleep}
Allows the XBee to determine when to wake up. The module can sleep for a specified time and wake for a short time to poll its parent for buffered data. If the parent has date the device will remain awake for a time, otherwise it will re-enter sleep mode immediately. 
\begin{itemize}
\item + suitable for DigiMesh, where the sleep clocks is accurate enough to get all nodes awake at the same time
\item + with DigiMesh, fully awake routers are not required, so they can be battery powered
\item - more power consumption due to accurate clock
\item - external controller must also wake when the XBee wakes to treat potentially received messages, even if there is no need to sample data
\end{itemize}

\paragraph{XBee sleep parameters}
\textbf{Router/Coordinator Configuration:} 
\begin{itemize}
\item RF Packet Buffering Timeout: 
\begin{itemize}
\item Sleep Period (SP) parameter. Max 30 seconds.
\item For cyclic sleep devices: SP should be set the same on routers and coordinators as it is on cyclic sleep end devices
\item For pin sleep devices: SP should be set equal to the time the end device can sleep, up to 30 seconds. If an end device sleeps longer than 30 seconds, parent and possibly non-parent devices must know when the device is awake. Therefore and devices that sleep longer than 30 seconds should transmit some kind of data (API frame) to alert the other devices that they can send data to the end device.
\end{itemize}
\item Child Poll Timeout: Sleep Number (SN) parameter: The number of Sleep Periods (SP) used to calculated end device poll timeout.

SP = 30
SN = 3E8
\end{itemize}
... ...
%--------------------------------------------------------------------

